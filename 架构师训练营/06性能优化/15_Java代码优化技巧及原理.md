# 性能优化

## Java代码优化技巧及原理

### 合理并谨慎使用多线程

使用场景（I/O 阻塞，多CPU 并发）
资源争用与同步问题
java.util.concurrent

启动线程数= [任务执行时间/ (任务执行时间- IO 等待时间)] * CPU 内核数
- 最佳启动线程数和CPU 内核数量成正比，和IO 阻塞时间成反比。如果任务都是CPU计算型任务，那么线程数最多不超过CPU 内核数，因为启动再多线程，CPU 也来不及调度;相反如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于提高任务并发度，提高系统吞吐能力，改善系统性能。

### 竞态条件与临界区

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。

在临界区中使用适当的同步就可以避免竞态条件。

### Java线程安全

允许被多个线程安全执行的代码称作线程安全的代码。

方法局部变量
- 局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。

方法局部的对象引用
- 如果在某个方法中创建的对象不会逃逸出该方法，那么它就是线程安全的。

对象成员变量
- 对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。

servlet是单实例的

### ThreadLocal

既是私有，又是共享

创建一个ThreadLocal 变量（X 类静态成员变量）：
- public static ThreadLocal myThreadLocal = new ThreadLocal();
存储此对象的值（A 类a 方法）：
- X.myThreadLocal.set("A thread local value");
读取一个ThreadLocal 对象的值（B 类b 方法）：
- String threadLocalValue = (String)X.myThreadLocal.get();

Thread 里面有 有map，里面存着ThreadLocal的map
map对象是线程共享，但是key-value是线程安全

### Java内存泄露

Java 内存泄漏是由于开发人员的错误引起的。

如果程序保留对永远不再使用的对象的引用，这些对象将会占用并耗尽内存。
- 长生命周期对象
- 静态容器
- 缓存

(一个static里的map)

合理使用线程池和对象池
- 复用线程或对象资源，避免在程序的生命期中创建和删除大量对象
- 池管理算法（记录哪些对象是空闲的，哪些对象正在使用）
- 对象内容清除（ThreadLocal 的清空）

使用合适的JDK 容器类（顺序表，链表，Hash）
- LinkList 和ArrayList 的区别及适用场景
- HashMap 的算法实现及应用场景
- 使用concurrent 包，ConcurrentHashMap 和HashMap 的线程安全特性有什么不同？

（hashmap线程不安全，concurrentHashMap性能要高，内置实现分段式加锁）

缩短对象生命周期，加速垃圾回收
- 减少对象驻留内存的时间
- 在使用时创建对象，用完释放
- 创建对象的步骤（静态代码段－静态成员变量－父类构造函数－子类构造函数）

使用I/O buffer 及NIO
- 延迟写与提前读策略
- 异步无阻塞IO 通信

优先使用组合代替继承
- 减少对象耦合
- 避免太深的继承层次带来的对象创建性能损失

合理使用单例模式
- 无状态对象
- 线程安全

（spring的service，dao都是单例无状态的，代码在tomcat中多线程执行的）

计算机的任何问题都可以通过虚拟层（或者中间层）解决
- 面向接口编程
- 7层网络协议
- JVM
- 编程框架
- 一致性hash 算法的虚拟化实现

