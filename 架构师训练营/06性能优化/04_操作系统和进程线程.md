# 性能优化

## 操作系统

### 程序运行时架构

程序是静态的。

程序运行起来以后，被称作进程。

代码从磁盘加载到内存，交给CPU执行

### 操作系统多任务运行环境

计算机的CPU 核心数是有限的。但是，服务器可以同时处理数以百计甚至数以千计的并发用户请求。

那么，计算机如何做到的？
- 进程分时执行

### 进程的运行期状态

运行：当一个进程在CPU 上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于CPU 的数目。

就绪：当一个进程获得了除CPU 以外的一切所需资源，只要得到CPU 即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。

阻塞：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待I/O 完成，等待锁……）而暂时停止运行，这时即使把CPU 分配给进程也无法运行，故称该进程处于阻塞状态。

### 进程 VS 线程

不同进程轮流在CPU 上执行，每次都要进行进程间CPU 切换，代价非常大。因此服务器应用通常是单进程多线程。

进程从操作系统获得基本的内存空间，所有的线程共享着进程的内存地址空间。而每个线程也会拥有自己私有的内存地址范围，其他线程不能访问。

#### 线程栈

#### Java Web 应用多线程运行时视图

图挺好的

### 线程安全

当某些代码修改内存堆（进程共享内存）里的数据的时候，如果有多个线程在同时执行，就可能会出现同时修改数据的情况，比如，两个线程同时对一个堆中的数据执行+1 操作，最终这个数据只会被加一次，这就是人们常说的线程安全问题，实际上线程的结果应该是依次加一，即最终的结果应该是+2。

这里要区分栈和堆的区别

栈：存放临时变量
堆：new出的对象信息。如果是一个单例对象，则会指向同一个对象

#### 临界区

多个线程访问共享资源的这段代码被称为临界区，解决线程安全问题的主要方法是使用锁，将临界区的代码加锁，只有获得锁的线程才能执行临界区代码。

lock.lock(); // 线程获得锁
i++; // 临界区代码，i位于堆中
lock.unlock(); // 线程释放锁

#### 阻塞导致高并发系统崩溃

锁（I/O）会引起线程阻塞。阻塞导致线程既不能继续执行，也不能释放资源。进而导致资源耗尽。最终导致系统崩溃。

#### 避免阻塞引起的崩溃

限流：控制进入计算机的请求数，进而减少创建的线程数。
降级：关闭部分功能程序的执行，尽早释放线程。
反应式：异步；无临界区（Actor 模型）

