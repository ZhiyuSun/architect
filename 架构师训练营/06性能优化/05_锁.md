# 性能优化

## 锁

### 锁原语 CAS

CAS（V,E,N）
- V 表示要更新的变量
- E 表示预期值
- N 表示新值

如果V 值等于E 值，则将V 的值设为N，若V 值和E值不同，什么都不做。
CAS 是一种系统原语，原语的执行必须是连续的，在执行过程中不允许被中断。

### Java 通过CAS 原语在对象头中修改Mark Word 实现加锁

### 偏向锁 轻量级锁 重量级锁

偏向锁：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价

轻量级锁：指当锁是偏向锁时，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能

重量级锁：指当锁是轻量级锁时，另一个线程虽然自旋，但自旋不会一直持续下去，当自旋到一定次数时，还没获取到锁，就会进入阻塞，该锁膨胀为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低

### 总线锁与缓存锁

总线锁：使用处理器的LOCK# 信号，当一个处理器在内存总线上输出此信号的时候，其他处理器的请求将被阻塞，该处理器独占内存。

缓存锁：是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行数据时，会使缓存行无效。

### 公平锁 非公平锁

公平锁就是多个线程按照申请锁的顺序来获取锁的。

非公平锁就是多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，可能会造成饥饿现象。

### 可重入锁

可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。

### 独享锁/互斥锁共享锁读写锁

独享锁/互斥锁：该锁一次只能被一个线程所持有
共享锁：该锁可以被多个线程所持有
读写锁：多个读线程之间并不互斥，而写线程则要求与任何线程互斥

### 乐观锁 悲观锁

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，检查是否已经被修改过，如果修改过，就放弃。

### 分段锁

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组的一段进行加锁操作。

JDK ConcurrentHashMap 是通过分段锁的形式来实现高效并发操作的。

### 自旋锁

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。


知鱼君注：第一次听到这么多锁的名字，晕