# 技术选型

## 分布式缓存

缓存：存储在计算机上的一个原始数据复制集，以便于访问– 维基百科

缓存是介于数据访问者和数据源之间的一种高速存储，当数据需要多次读取的时候，用
于加快读取的速度。

### 无处不在的缓存

CPU 缓存
操作系统缓存
数据库缓存
JVM 编译缓存
CDN 缓存
代理与反向代理缓存
前端缓存
应用程序缓存
分布式对象缓存

### 缓存的关键指标

缓存命中率
- 缓存是否有效依赖于能多少次重用同一个缓存响应业务请求，这个度量指标被称作缓存命中率。
- 如果查询一个缓存，十次查询九次能够得到正确结果，那么它的命中率是90%。

### 影响缓存命中率的主要指标

#### 缓存键集合大小

缓存中的每个对象使用缓存键进行识别，定位一个对象的唯一方式就是对缓存键执行精确匹配。例如，如果想为每个商品缓存在线商品信息，你需要使用商品ID 作为缓存键。

换句话说，缓存键空间是你的应用能够生成的所有键的数量。从统计数字上看，应用生成的唯一键越多，重用的机会越小。例如，如果想基于客户IP 地址缓存天气数据，则可能有多达40 亿个键(这是所有可能的IP 地址的数量)。如果要基于客户来源国家缓存天气数据，则可能仅需几百个缓存键(世界上所有国家的数量)。一定要想办法减少可能的缓存键数量。键数量越少，缓存的效率越高。

#### 缓存可使用内存空间

缓存可使用内存空间直接决定了缓存对象的平均大小和缓存对象数量。因为缓存通常存储在内存中，缓存对象可用空间受到严格限制且相对昂贵。如果想缓存更多的对象，就需要先删除老的对象，再添加新的对象。替换(清除)对象会降低缓存命中率，因为缓存对象被删除后，将来的请求就无法命中了。物理上能缓存的对象越多，缓存命中率就越高。

#### 缓存对象生存时间

缓存对象生存时间称为TTL（ Time To Live ）。在某些场景中，例如，缓存天气预报数据15 分钟没问题。在这个场景下， 你可以设置缓存对象预定义TTL 为15 分钟。在其他场景中，你可能不能冒险使用过于陈旧的数据。例如，在一个电子商务系统中，店铺管理员可能在任何时刻修改商品价格，如果这些价格需要准确地展示在整个网站中。在这个场景下，你需要在每次商品价格修改时让缓存失效。简单讲，对象缓存的时间越长，缓存对象被重用的可能性就越高。

### 实现形式

- 代理缓存
- 反向代理缓存
- 多层反向代理缓存
- 内容分发网络（CDN）
- CDN同时配置静态文件和动态内容
- 通读缓存（read-through）
- 旁路缓存（cache-aside）
- 浏览器对象缓存
- 本地对象缓存
    - 对象直接缓存在应用程序内存中。
    - 对象存储在共享内存，同一台机器的多个进程可以访问它们。
    - 缓存服务器作为独立应用和应用程序部署在同一个服务器上。
- 远程分布式对象缓存
- 分布式对象缓存

### 分布式对象缓存的一致性hash算法

余数hash导致大部分key不能命中
一致性hash只导致一小部分key不能命中

基于虚拟节点的一致性Hash算法

### 技术栈各个层次的缓存

### 缓存为什么能显著提升性能

- 缓存数据通常来自内存，比磁盘上的数据有更快的访问速度。
- 缓存存储数据的最终结果形态，不需要中间计算，减少CPU 资源的消耗。
- 缓存降低数据库、磁盘、网络的负载压力，使这些I/O 设备获得更好的响应特性。

缓存是系统性能优化的大杀器

- 技术简单
- 性能提升显著
- 应用场景多

### 合理使用缓存

- 使用缓存对提高系统性能有很多好处，但是不合理的使用缓存可能非但不能提高系统的性能，还会成为系统的累赘，甚至风险。实践中，缓存滥用的情景屡见不鲜——过分依赖缓存、不合适的数据访问特性等。

- 频繁修改的数据：这种数据如果缓存起来，由于频繁修改，应用还来不及读取就已失效或更新，徒增系统负担。一般说来，数据的读写比在2:1以上，缓存才有意义。

- 没有热点的访问：缓存使用内存作为存储，内存资源宝贵而有限，不能将所有数据都缓存起来，如果应用系统访问数据没有热点，不遵循二八定律，即大部分数据访问不是集中在小部分数据上，那么缓存就没有意义，因为大部分数据还没有被再次访问就已经被挤出缓存了。

- 数据不一致与脏读：一般会对缓存的数据设置失效时间，一旦超过失效时间，就要从数据库中重新加载。因此应用要容忍一定时间的数据不一致，如卖家已经编辑了商品属性，但是需要过一段时间才能被买家看到。在互联网应用中，这种延迟通常是可以接受的，但是具体应用仍需慎重对待。还有一种策略是数据更新时立即更新缓存，不过也会带来更多系统开销和事务一致性的问题。因此数据更新时通知缓存失效，删除该缓存数据，是一种更加稳妥的做法。

“计算机科学中只有三件事最困难:缓存失效，命名事物，计数错误。” ——Phil Karlton

- 缓存雪崩：缓存是为了提高数据读取性能的，缓存数据丢失或者缓存不可用不会影响到应用程序的处——它可以从数据库直接获取数据。但是随着业务的发展，缓存会承担大部分的数据访问压力，数据库已经习惯了有缓存的日子，所以当缓存服务崩溃的时候，数据库会因为完全不能承受如此大的压力而宕机，进而导致整个网站不可用。这种情况，被称作缓存雪崩，发生这种故障，甚至不能简单的重启缓存服务器和数据库服务器来恢复网站访问。

- 缓存预热：缓存中存放的是热点数据，热点数据又是缓存系统利用LRU（最近最久未用）算法对不断访问的数据筛选淘汰出来的，这个过程需要花费较长的时间，在这段时间，系统的性能和数据库负载都不太好，那么最好在缓存系统启动的时候就把热点数据加载好，这个缓存预加载手段叫做缓存预热（warm up）。对于一些元数据如城市地名列表、类目信息，可以启动时加载数据库中全部数据到缓存进行预热。

- 缓存穿透：如果不恰当的业务、或者恶意攻击持续高并发的请求某个不存在的数据，因为缓存没有保存该数据，所有的请求都会落到数据库上，会对数据库造成很大的压力，甚至崩溃。一个简单的对策是将不存在的数据也缓存起来（其value 值为null），并设定一个较短的失效时间。

### Redis VS Memcached

- Redis 支持复杂的数据结构
- Redis 支持多路复用异步I/O 高性能
- Redis 支持主从复制高可用
- Redis 原生集群与share nothing 集群模式

#### Redis集群

- Redis 集群预分好16384个桶，当需要在Redis 集群中放置一个key-value 时，根据CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。
- redis-cluster 把所有的物理节点映射到[0-16383]slot上（不一定是平均分配），cluster 负责维护slot 与服务器的映射关系。
- 客户端与Redis 节点直连，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
- 所有的Redis 节点彼此互联。

